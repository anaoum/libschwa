/* -*- Mode: C++; indent-tabs-mode: nil -*- */
#ifndef SCHWA_HASHTABLE_H_
#define SCHWA_HASHTABLE_H_

#include <iterator>
#include <memory>
#include <stdexcept>

#include <schwa/_base.h>
#include <schwa/io/logging.h>
#include <schwa/hash.h>


namespace schwa {

  /**
   * This table assumes that the hash value of 0 cannot be generated by the hasher.
   * Value types:
   * - must store their hash as their first member
   * - must be default constructable, zeroing the hash member
   * - cannot be virtual
   **/
  template <typename KEY, typename T, size_t INDEX_BITS=24, size_t VALUE_BITS=64-INDEX_BITS, typename HASHER=schwa::Hasher64<KEY>, typename ALLOC=std::allocator<T>>
  class FeatureHashtable {
  public:
    using allocator_type = ALLOC;
    using difference_type = ptrdiff_t;
    using key_type = KEY;
    using hasher = HASHER;
    using mapped_type = T;
    using size_type = size_t;

    using reference = typename allocator_type::reference;
    using const_reference = typename allocator_type::const_reference;
    using pointer = typename allocator_type::pointer;
    using const_pointer = typename allocator_type::const_pointer;

    static constexpr const size_t TABLE_INDEX_BITS = INDEX_BITS;  //!< Number of bits from the hash to use as the index into the table.
    static constexpr const uint64_t TABLE_INDEX_MASK = (static_cast<uint64_t>(1) << TABLE_INDEX_BITS) - static_cast<uint64_t>(1);
    static constexpr const size_t TABLE_SIZE = 1 << TABLE_INDEX_BITS;
    static constexpr const size_t VALUE_HASH_BITS = VALUE_BITS;  //!< Number of bits from the hash to store in the value.
    static constexpr const uint64_t VALUE_HASH_MASK = ~((static_cast<uint64_t>(1) << (64 - VALUE_HASH_BITS)) - static_cast<uint64_t>(1));

    static_assert(sizeof(typename hasher::result_type) == 8, "64-bit hash function required");
    static_assert(INDEX_BITS > 0, "INDEX_BITS must be non-zero");
    static_assert(INDEX_BITS <= 64, "INDEX_BITS cannot exceed 64 since the hash function is 64-bit.");
    static_assert(VALUE_BITS <= 64, "VALUE_BITS cannot exceed 64 since the hash function is 64-bit.");

  private:
    template <typename TABLE>
    class _iterator : public std::iterator<std::forward_iterator_tag, typename TABLE::mapped_type> {
    public:
      using difference_type = typename std::iterator<std::forward_iterator_tag, typename TABLE::mapped_type>::difference_type;
      using iterator_category = typename std::iterator<std::forward_iterator_tag, typename TABLE::mapped_type>::iterator_category;
      using pointer = typename std::iterator<std::forward_iterator_tag, typename TABLE::mapped_type>::pointer;
      using reference = typename std::iterator<std::forward_iterator_tag, typename TABLE::mapped_type>::reference;
      using value_type = typename std::iterator<std::forward_iterator_tag, typename TABLE::mapped_type>::value_type;

    private:
      bool _ended;
      bool _initialised;
      TABLE *_ht;
      size_t _index;

      void
      _increment(void) {
        // Don't do anything if it's at the end.
        if (SCHWA_UNLIKELY(_ended))
          return;
        while (true) {
          // Increment the index if not initialised.
          if (SCHWA_LIKELY(_initialised))
            ++_index;
          else
            _initialised = true;
          // Have we reached the end of the table?
          if (_index == _ht->max_size()) {
            _ended = true;
            _ht = nullptr;
            _index = 0;
            break;
          }
          // Otherwise, is the current entry filled?
          pointer entry = &_ht->_table[_index];
          if (_ht->_get_masked_entry_hash(entry) != 0)
            break;
        }
      }

    public:
      _iterator(void) : _ended(true), _initialised(true), _ht(nullptr), _index(0) { }
      explicit _iterator(TABLE &ht) : _ended(false), _initialised(false), _ht(&ht), _index(0) { }
      _iterator(TABLE &ht, size_t index) : _ended(false), _initialised(true), _ht(&ht), _index(index) { }
      _iterator(const _iterator &o) : _ended(o._ended), _initialised(o._initialised), _ht(o._ht), _index(o._index) { }
      _iterator(const _iterator &&o) : _ended(o._ended), _initialised(o._initialised), _ht(o._ht), _index(o._index) { }
      ~_iterator(void) { }

      inline bool operator ==(const _iterator &o) const { return _ended == o._ended && _initialised == o._initialised && _ht == o._ht && _index == o._index; }
      inline bool operator !=(const _iterator &o) const { return _ended != o._ended || _initialised != o._initialised || _ht != o._ht || _index != o._index; }

      inline reference operator *(void) { if (SCHWA_UNLIKELY(!_initialised)) { _increment(); } return _ht->_table[_index]; }
      inline pointer operator ->(void) { return &(*this); }

      _iterator &operator ++(void) { if (SCHWA_UNLIKELY(!_initialised)) { _increment(); } _increment(); return *this; }
      _iterator operator ++(int) { iterator it(*this); ++(*this); return it; }

      _iterator &
      operator =(const _iterator &o) {
        _ended = o._ended;
        _initialised = o._initialised;
        _ht = o._ht;
        _index = o._index;
      }

      friend inline std::ostream &
      operator <<(std::ostream &out, const _iterator &it) {
        return out << "[" << it._ended << " " << it._initialised << " " << it._ht << " " << it._index << "]";
      }
    };

  public:
    using iterator = _iterator<FeatureHashtable>;
    using const_iterator = _iterator<const FeatureHashtable>;

    friend class _iterator<FeatureHashtable>;
    friend class _iterator<const FeatureHashtable>;

  private:
    hasher _hasher;  //!< 64-bit hasher instance.
    allocator_type _allocator;  //!< Allocator instance.
    mapped_type *const _table;  //!< The underlying table. No chaining as collisions are accepted.
    size_type _size;  //!< The population count; how many entries exist in the table.

    inline reference
    _create_entry(pointer entry, const uint64_t masked_hash) {
      *reinterpret_cast<uint64_t *>(entry) |= masked_hash;
      ++_size;
      return *entry;
    }

    inline uint64_t
    _get_masked_entry_hash(const_pointer entry) const {
      return *reinterpret_cast<const uint64_t *>(entry) & VALUE_HASH_MASK;
    }

    iterator
    _find(const key_type &key, uint64_t &masked_hash, bool &exists) {
      const uint64_t hash = _hasher(key);
      masked_hash = hash & VALUE_HASH_MASK;
      const size_t start_index = hash & TABLE_INDEX_MASK;

      for (size_t nmisses = 0; nmisses != TABLE_SIZE; ++nmisses) {
        // Get the next entry and its masked hash.
        const size_t index = (start_index + nmisses) % TABLE_SIZE;  // This can be adjusted for alternative probing values.
        pointer entry = &_table[index];
        const uint64_t masked_entry_hash = _get_masked_entry_hash(entry);

        // If entry the same as the key, return the entry.
        if (masked_entry_hash == masked_hash) {
          exists = true;
          return iterator(*this, index);
        }

        // If the entry is unoccupied, store the key, increment the population count, and return the entry.
        if (masked_entry_hash == 0) {
          exists = false;
          return iterator(*this, index);
        }
      }

      // The table is full and the entry does not exist.
      exists = false;
      return iterator();
    }

    const_iterator
    _find(const key_type &key) const {
      const uint64_t hash = _hasher(key);
      const uint64_t masked_hash = hash & VALUE_HASH_MASK;
      const size_t start_index = hash & TABLE_INDEX_MASK;

      for (size_t nmisses = 0; nmisses != TABLE_SIZE; ++nmisses) {
        // Get the next entry and its masked hash.
        const size_t index = (start_index + nmisses) % TABLE_SIZE;  // This can be adjusted for alternative probing values.
        const_pointer entry = &_table[index];
        const uint64_t masked_entry_hash = _get_masked_entry_hash(entry);

        // If entry the same as the key, return the entry.
        if (masked_entry_hash == masked_hash)
          return const_iterator(*this, index);

        // If the entry is unoccupied, bail as the probing has failed to find the element.
        if (masked_entry_hash == 0)
          break;
      }

      // The entry was not found.
      return const_iterator();
    }

  public:
    explicit FeatureHashtable(const hasher &hf=hasher(), const allocator_type &allocator=allocator_type()) :
        _hasher(hf),
        _allocator(allocator),
        _table(_allocator.allocate(TABLE_SIZE)),
        _size(0)
      {
      // Construct the table objects.
      for (size_t i = 0; i != TABLE_SIZE; ++i)
        _allocator.construct(_table + i);
    }

    ~FeatureHashtable(void) {
      // Destruct the table objects and dealloc the table.
      for (size_t i = 0; i != TABLE_SIZE; ++i)
        _allocator.destroy(_table + i);
      _allocator.deallocate(_table, TABLE_SIZE);
    }

    // Capacity
    inline bool empty(void) const { return _size == 0; }
    inline size_type max_size(void) const { return TABLE_SIZE; }
    inline size_type size(void) const { return _size; }

    // Iterators
    inline iterator begin(void) { return iterator(*this); }
    inline iterator end(void) { return iterator(); }
    inline const_iterator begin(void) const { return const_iterator(*this); }
    inline const_iterator end(void) const { return const_iterator(); }
    inline const_iterator cbegin(void) const { return const_iterator(*this); }
    inline const_iterator cend(void) const { return const_iterator(); }

    // Observers
    inline allocator_type get_allocator(void) const noexcept { return _allocator; }
    inline hasher hash_function(void) const { return _hasher; }

    // Hash policy
    inline float load_factor(void) const noexcept { return _size / static_cast<float>(TABLE_SIZE); }

    // Element lookup
    inline iterator
    find(const key_type &key) {
      uint64_t masked_hash;
      bool exists;
      iterator it = _find(key, masked_hash, exists);
      return exists ? it : iterator();
    }

    inline const_iterator
    find(const key_type &key) const {
      return _find(key);
    }

    // Element access
    reference
    operator [](const key_type &key) {
      uint64_t masked_hash;
      bool exists;
      iterator it = _find(key, masked_hash, exists);
      if (SCHWA_UNLIKELY(it == end()))
        throw std::out_of_range("The table is full and the entry does not already exist in the table.");
      else if (exists)
        return *it;
      else
        return _create_entry(&(*it), masked_hash);
    }

    const_reference
    operator [](const key_type &key) const {
      const_iterator it = _find(key);
      if (SCHWA_UNLIKELY(it == end()))
        throw std::out_of_range("The entry does not exist in the table.");
      return *it;
    }

  private:
    SCHWA_DISALLOW_COPY_AND_ASSIGN(FeatureHashtable);
  };

}

#endif  // SCHWA_HASHTABLE_H_
