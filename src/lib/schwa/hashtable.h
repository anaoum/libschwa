/* -*- Mode: C++; indent-tabs-mode: nil -*- */
#ifndef SCHWA_HASHTABLE_H_
#define SCHWA_HASHTABLE_H_

#include <cstdlib>
#include <iterator>
#include <iomanip>
#include <iostream>
#include <memory>
#include <new>
#include <type_traits>
#include <stdexcept>

#include <schwa/_base.h>
#include <schwa/io/logging.h>
#include <schwa/hash.h>
#include <schwa/msgpack.h>


namespace schwa {

  enum class FeatureStorage : uint8_t {
    UNSPECIFIED, DENSE, SPARSE,
  };


  class FeatureType {
  public:
    using id_type = uint8_t;

  private:
    const id_type _id;
    FeatureStorage _storage;

  public:
    explicit FeatureType(id_type id, FeatureStorage storage=FeatureStorage::UNSPECIFIED) : _id(id), _storage(storage) { }

    inline id_type id(void) const { return _id; }
    inline FeatureStorage storage(void) const { return _storage; }

    inline void set_storage(FeatureStorage storage) { _storage = storage; }

  private:
    SCHWA_DISALLOW_COPY_AND_ASSIGN(FeatureType);
  };


  using Label = uint16_t;


  struct FeatureHashtableEntryBase {
  public:
    static_assert(sizeof(Label) == 2, "Unexpected sizeof(Label)");

    static constexpr const size_t HASH_BITS = 48;
    static constexpr const uint64_t HASH_MASK = ~((static_cast<uint64_t>(1) << (64 - HASH_BITS)) - static_cast<uint64_t>(1));
    static constexpr const uint64_t LABEL_MASK = (static_cast<uint64_t>(1) << (64 - HASH_BITS)) - static_cast<uint64_t>(1);

  protected:
    uint64_t _value;  //!< The top 48 bits are for the hash and the bottom 16 bits are for the label.

  public:
    FeatureHashtableEntryBase(void) : _value(0) { }
    FeatureHashtableEntryBase(uint64_t masked_hash, Label label) : _value(build_value(masked_hash, label)) { }

    inline uint16_t label(void) const { return _value & LABEL_MASK; }
    inline uint64_t masked_hash(void) const { return _value & HASH_MASK; }
    inline uint64_t value(void) const { return _value; }
    inline void set_label(const Label label) { _value = ((_value & HASH_MASK) | label); }
    inline void set_masked_hash(const uint64_t masked_hash) { _value = (masked_hash | (_value & LABEL_MASK)); }

    static inline uint64_t build_value(const uint64_t masked_hash, const Label label) { return masked_hash | static_cast<uint64_t>(label); }
    static inline uint64_t mask_hash(const uint64_t hash) { return hash & HASH_MASK; }

  private:
    SCHWA_DISALLOW_COPY_AND_ASSIGN(FeatureHashtableEntryBase);
  };


  /**
   * This table assumes that the hash value of 0 cannot be generated by the hasher.
   * ENTRY type:
   * - must be a subclass of FeatureHashtableEntryBase
   * - must be default constructable
   * - must not be virtual
   *
   * ENTRY classes should define the \p clear, \p deserialise, and \p serialise methods,
   * accounting for the \p _value member in FeatureHashtableEntryBase. They are non-virtual for
   * speed reasons.
   *
   * This class is not thread-safe.
   **/
  template <typename ENTRY, size_t INDEX_BITS=24, typename ALLOC=std::allocator<ENTRY>>
  class FeatureHashtable {
  public:
    static_assert(std::is_base_of<FeatureHashtableEntryBase, ENTRY>::value, "ENTRY type must be a subclass of FeatureHashtableEntryBase.");
    static_assert(std::is_default_constructible<ENTRY>::value, "ENTRY type must be default constructable.");
    static_assert(std::has_virtual_destructor<ENTRY>::value == false, "ENTRY type cannot be virtual.");
    static_assert(INDEX_BITS > 0, "INDEX_BITS must be non-zero");
    static_assert(INDEX_BITS <= 64, "INDEX_BITS cannot exceed 64 since the hash function is 64-bit.");

    using allocator_type = ALLOC;
    using difference_type = ptrdiff_t;
    using mapped_type = ENTRY;
    using size_type = size_t;

    using reference = typename allocator_type::reference;
    using const_reference = typename allocator_type::const_reference;
    using pointer = typename allocator_type::pointer;
    using const_pointer = typename allocator_type::const_pointer;

    static constexpr const size_t TABLE_INDEX_BITS = INDEX_BITS;  //!< Number of bits from the hash to use as the index into the table.
    static constexpr const uint64_t TABLE_INDEX_MASK = (static_cast<uint64_t>(1) << TABLE_INDEX_BITS) - static_cast<uint64_t>(1);
    static constexpr const size_t TABLE_SIZE = 1 << TABLE_INDEX_BITS;

  private:
    template <typename TABLE>
    class _iterator : public std::iterator<std::forward_iterator_tag, typename TABLE::mapped_type> {
    public:
      using super_type = std::iterator<std::forward_iterator_tag, typename TABLE::mapped_type>;
      using difference_type = typename super_type::difference_type;
      using iterator_category = typename super_type::iterator_category;
      using pointer = typename super_type::pointer;
      using reference = typename super_type::reference;
      using value_type = typename super_type::value_type;

    private:
      mutable bool _ended;
      mutable bool _initialised;
      mutable TABLE *_ht;
      mutable size_t _index;

      void
      _increment(void) const {
        // Don't do anything if it's at the end.
        if (SCHWA_UNLIKELY(_ended))
          return;
        while (true) {
          // Increment the index if not initialised.
          if (SCHWA_LIKELY(_initialised))
            ++_index;
          else
            _initialised = true;
          // Have we reached the end of the table?
          if (_index == _ht->max_size()) {
            _ended = true;
            _ht = nullptr;
            _index = 0;
            break;
          }
          // Otherwise, is the current entry filled?
          pointer entry = &_ht->_table[_index];
          if (entry->masked_hash() != 0)
            break;
        }
      }

    public:
      _iterator(void) : _ended(true), _initialised(true), _ht(nullptr), _index(0) { }
      explicit _iterator(TABLE &ht) : _ended(false), _initialised(false), _ht(&ht), _index(0) { }
      _iterator(TABLE &ht, size_t index) : _ended(false), _initialised(true), _ht(&ht), _index(index) { }
      _iterator(const _iterator &o) : _ended(o._ended), _initialised(o._initialised), _ht(o._ht), _index(o._index) { }
      _iterator(const _iterator &&o) : _ended(o._ended), _initialised(o._initialised), _ht(o._ht), _index(o._index) { }
      ~_iterator(void) { }

      inline bool
      operator ==(const _iterator &o) const {
        if (SCHWA_UNLIKELY(!_initialised))
          _increment();
        if (SCHWA_UNLIKELY(!o._initialised))
          o._increment();
        return _ended == o._ended && _initialised == o._initialised && _ht == o._ht && _index == o._index;
      }
      inline bool operator !=(const _iterator &o) const { return !(*this == o); }

      inline reference
      operator *(void) const {
        if (SCHWA_UNLIKELY(!_initialised))
          _increment();
        return _ht->_table[_index];
      }
      inline pointer operator ->(void) const { return &(**this); }

      inline _iterator &
      operator ++(void) {
        if (SCHWA_UNLIKELY(!_initialised))
          _increment();
        _increment();
        return *this;
      }
      inline _iterator operator ++(int) { iterator it(*this); ++(*this); return it; }

      _iterator &
      operator =(const _iterator &o) {
        _ended = o._ended;
        _initialised = o._initialised;
        _ht = o._ht;
        _index = o._index;
        return *this;
      }

      friend inline std::ostream &
      operator <<(std::ostream &out, const _iterator &it) {
        return out << "[" << it._ended << " " << it._initialised << " " << it._ht << " " << it._index << "]";
      }
    };

  public:
    using iterator = _iterator<FeatureHashtable>;
    using const_iterator = _iterator<const FeatureHashtable>;

    friend class _iterator<FeatureHashtable>;
    friend class _iterator<const FeatureHashtable>;

  private:
    allocator_type _allocator;  //!< Allocator instance.
    mapped_type *const _table;  //!< The underlying table. No chaining as collisions are accepted.
    void *const _xxhash_state;  //<! Array of bytes used to maintain partial xxhash state.
    size_type _size;  //!< The population count; how many entries exist in the table.

    inline reference
    _create_entry(pointer entry, const uint64_t masked_hash, const Label &label) {
      if (SCHWA_LIKELY(entry->value() == 0))
        ++_size;
      entry->set_masked_hash(masked_hash);
      entry->set_label(label);
      return *entry;
    }


    iterator
    _locate_dense(const size_t start_index, const Label label, const uint64_t value, bool &exists) {
      const size_t index = (start_index + label) % TABLE_SIZE;
      const pointer entry = &_table[index];
      const uint64_t entry_value = entry->value();
      //LOG(INFO) << "[_locate_dense] index=" << std::dec << index << " entry_value=0x" << std::hex << entry_value << std::endl;

      // If the entry is unoccupied, return an iterator to the position in the table.
      if (entry_value == 0) {
        exists = false;
        return iterator(*this, index);
      }

      // If the entry is the same as the key, return an iterator to the entry.
      if (entry_value == value) {
        exists = true;
        return iterator(*this, index);
      }

      // FIXME what should we do if a dense feature index doesn't have the correct hash in the entry?
      //LOG(INFO) << "[_locate_dense] FIXME entry_value=0x" << std::hex << entry_value << " value=0x" << std::hex << value << std::endl;
      exists = false;
      return iterator(*this, index);
    }

    iterator
    _locate_sparse(const size_t start_index, const uint64_t value, bool &exists) {
      // Probe the table entries.
      for (size_t nmisses = 0; nmisses != TABLE_SIZE; ++nmisses) {
        // Get the next entry and its masked hash.
        const size_t index = (start_index + nmisses*nmisses) % TABLE_SIZE;  // Quadratic probing.
        const_reference entry = _table[index];
        const uint64_t entry_value = entry.value();
        //LOG(INFO) << "[_locate_sparse] index=" << std::dec << index << " entry_value=0x" << std::hex << entry_value << std::endl;

        // If the entry is unoccupied, return an iterator to the position in the table.
        if (entry_value == 0) {
          exists = false;
          return iterator(*this, index);
        }

        // If the entry is the same as the key, return an iterator to the entry.
        if (entry_value == value) {
          exists = true;
          return iterator(*this, index);
        }
      }

      // The table is full and the entry does not exist.
      exists = false;
      return iterator();
    }

    inline iterator
    _locate(const FeatureType &type, const uint64_t hash, const Label label, uint64_t &masked_hash, bool &exists) {
      masked_hash = FeatureHashtableEntryBase::mask_hash(hash);
      const uint64_t value = FeatureHashtableEntryBase::build_value(masked_hash, label);
      const size_t start_index = hash & TABLE_INDEX_MASK;
      //LOG(INFO) << "[_locate] hash=0x" << std::hex << hash << " masked_hash=0x" << std::hex << masked_hash << " start_index=" << std::dec << start_index << std::endl;

      // Unless the feature type storage is defined to be DENSE, use sparse features.
      if (type.storage() == FeatureStorage::DENSE)
        return _locate_dense(start_index, label, value, exists);
      else
        return _locate_sparse(start_index, value, exists);
    }


    const_iterator
    _locate_dense(const size_t start_index, const Label label, const uint64_t value) const {
      const size_t index = (start_index + label) % TABLE_SIZE;
      const_reference entry = _table[index];
      const uint64_t entry_value = entry.value();
      //LOG(INFO) << "[_locatewdense const] index=" << std::dec << index << " entry_value=0x" << std::hex << entry_value << std::endl;

      // If the entry is unoccupied, return not found.
      if (entry_value == 0)
        return const_iterator();

      // If the entry is the same as the key, return an iterator to the entry.
      if (entry_value == value)
        return const_iterator(*this, index);

      // FIXME what should we do if a dense feature index doesn't have the correct hash in the entry?
      LOG(INFO) << "[_locate_dense const] FIXME what should we do if a dense feature index doesn't have the correct hash in the entry?" << std::endl;
      return const_iterator(*this, index);
    }

    const_iterator
    _locate_sparse(const size_t start_index, const uint64_t value) const {
      // Probe the table entries.
      for (size_t nmisses = 0; nmisses != TABLE_SIZE; ++nmisses) {
        // Get the next entry and its masked hash.
        const size_t index = (start_index + nmisses*nmisses) % TABLE_SIZE;  // Quadratic probing.
        const pointer entry = &_table[index];
        const uint64_t entry_value = entry->value();
        //LOG(INFO) << "[_locate_sparse const] index=" << std::dec << index << " entry_value=0x" << std::hex << entry_value << std::endl;

        // If the entry is unoccupied, return not found.
        if (entry_value == 0)
          return const_iterator();

        // If the entry is the same as the key, return an iterator to the entry.
        if (entry_value == value)
          return const_iterator(*this, index);
      }

      // The entry does not exist.
      return const_iterator();
    }

    inline const_iterator
    _locate(const FeatureType &type, const uint64_t hash, const Label label) const {
      const size_t start_index = hash & TABLE_INDEX_MASK;
      const uint64_t masked_hash = FeatureHashtableEntryBase::mask_hash(hash);
      const uint64_t value = FeatureHashtableEntryBase::build_value(masked_hash, label);
      //LOG(INFO) << "[_locate const] hash=0x" << std::hex << hash << " masked_hash=0x" << std::hex << masked_hash << " start_index=" << std::dec << start_index << std::endl;

      // Unless the feature type storage is defined to be DENSE, use sparse features.
      if (type.storage() == FeatureStorage::DENSE)
        return _locate_dense(start_index, label, value);
      else
        return _locate_sparse(start_index, value);
    }


    template <typename FN>
    void
    _for_each_label_dense(const size_t start_index, const uint64_t masked_hash, const Label label_begin, const Label label_end, FN &fn) const {
      size_t index = start_index + label_begin;
      if (SCHWA_UNLIKELY(index >= TABLE_SIZE))
        index = 0;

      for (Label label = label_begin; label != label_end; ++label, ++index) {
        if (SCHWA_UNLIKELY(index == TABLE_SIZE))
          index = 0;
        const_reference entry = _table[index];
        const uint64_t entry_value = entry.value();
        const uint64_t value = FeatureHashtableEntryBase::build_value(masked_hash, label);

        // FIXME what should we do if a dense feature index doesn't have the correct hash in the entry?
        if (entry_value == value)
          fn(label, entry);
      }
    }

    template <typename FN>
    void
    _for_each_label_sparse(const size_t start_index, const uint64_t masked_hash, const Label label_begin, const Label label_end, FN &fn) const {
      // Probe the table entries.
      for (size_t nmisses = 0; nmisses != TABLE_SIZE; ++nmisses) {
        // Get the next entry and its masked hash.
        const size_t index = (start_index + nmisses*nmisses) % TABLE_SIZE;  // Quadratic probing.
        const_reference entry = _table[index];
        const uint64_t entry_value = entry.value();

        // If the entry is unoccupied, bail.
        if (entry_value == 0)
          break;

        // If the masked hash is the same, extract the label.
        if (entry.masked_hash() == masked_hash) {
          const Label label = entry.label();
          if (SCHWA_LIKELY(label >= label_begin && label < label_end))
            fn(label, entry);
        }
      }
    }

    template <typename FN>
    void
    _for_each_label(const FeatureType &type, const uint64_t hash, const Label label_begin, const Label label_end, FN &fn) const {
      const size_t start_index = hash & TABLE_INDEX_MASK;
      const uint64_t masked_hash = FeatureHashtableEntryBase::mask_hash(hash);

      // Unless the feature type storage is defined to be DENSE, use sparse features.
      if (type.storage() == FeatureStorage::DENSE)
        _for_each_label_dense(start_index, masked_hash, label_begin, label_end, fn);
      else
        _for_each_label_sparse(start_index, masked_hash, label_begin, label_end, fn);
    }


    /**
     * Hashes together the feature type identifier and the contextual predicate using xxhash's
     * state-based hasher to form a combined digest. Returns the resultant hash.
     **/
    template <typename VALUE, typename HASHER>
    inline uint64_t
    _hash(const FeatureType &type, const VALUE &value, const HASHER &hasher) const {
      const FeatureType::id_type type_id = type.id();
      third_party::xxhash::XXH64_resetState(_xxhash_state, 0);
      third_party::xxhash::XXH64_update(_xxhash_state, &type_id, sizeof(decltype(type_id)));
      hasher(value, _xxhash_state);
      return third_party::xxhash::XXH64_intermediateDigest(_xxhash_state);
    }


    // ============================================================================================
    template <typename VALUE, typename HASHER>
    inline iterator
    _find(const FeatureType &type, const VALUE &value, const Label label, const HASHER &hasher) {
      const uint64_t hash = _hash(type, value, hasher);
      uint64_t masked_hash;
      bool exists;
      iterator it = _locate(type, hash, label, masked_hash, exists);
      return exists ? it : iterator();
    }

    template <typename VALUE, typename HASHER>
    inline const_iterator
    _find(const FeatureType &type, const VALUE &value, const Label label, const HASHER &hasher) const {
      const uint64_t hash = _hash(type, value, hasher);
      return _locate(type, hash, label);
    }

    template <typename VALUE, typename HASHER>
    inline reference
    _get(const FeatureType &type, const VALUE &value, const Label label, const HASHER &hasher) {
      const uint64_t hash = _hash(type, value, hasher);
      uint64_t masked_hash;
      bool exists;
      iterator it = _locate(type, hash, label, masked_hash, exists);
      if (SCHWA_UNLIKELY(it == end()))
        throw std::out_of_range("The table is full and the entry does not already exist in the table.");
      else if (exists)
        return *it;
      else
        return _create_entry(&(*it), masked_hash, label);
    }

    template <typename VALUE, typename HASHER>
    inline const_reference
    _get(const FeatureType &type, const VALUE &value, const Label label, const HASHER &hasher) const {
      const uint64_t hash = _hash(type, value, hasher);
      const_iterator it = _locate(type, hash, label);
      if (SCHWA_UNLIKELY(it == end()))
        throw std::out_of_range("The entry does not exist in the table.");
      return *it;
    }

  public:
    explicit FeatureHashtable(const allocator_type &allocator=allocator_type()) :
        _allocator(allocator),
        _table(_allocator.allocate(TABLE_SIZE)),
        _xxhash_state(std::malloc(third_party::xxhash::XXH64_sizeofState())),
        _size(0)
      {
      // Ensure the xxhash state was allocated successfully.
      if (SCHWA_UNLIKELY(_xxhash_state == nullptr))
        throw std::bad_alloc();

      // Construct the table objects.
      for (size_t i = 0; i != TABLE_SIZE; ++i)
        _allocator.construct(_table + i);
    }

    ~FeatureHashtable(void) {
      // Dealloc the xxhash state.
      std::free(_xxhash_state);

      // Destruct the table objects and dealloc the table.
      for (size_t i = 0; i != TABLE_SIZE; ++i)
        _allocator.destroy(_table + i);
      _allocator.deallocate(_table, TABLE_SIZE);
    }


    // Capacity
    inline bool empty(void) const { return _size == 0; }
    inline size_type max_size(void) const { return TABLE_SIZE; }
    inline size_type size(void) const { return _size; }

    // Iterators
    inline iterator begin(void) { return iterator(*this); }
    inline iterator end(void) { return iterator(); }
    inline const_iterator begin(void) const { return const_iterator(*this); }
    inline const_iterator end(void) const { return const_iterator(); }
    inline const_iterator cbegin(void) const { return const_iterator(*this); }
    inline const_iterator cend(void) const { return const_iterator(); }

    // Observers
    inline allocator_type get_allocator(void) const noexcept { return _allocator; }

    // Hash policy
    inline float load_factor(void) const noexcept { return _size / static_cast<float>(TABLE_SIZE); }

    // Element lookup
    template <typename VALUE, typename HASHER=schwa::Hasher64<VALUE>>
    inline iterator
    find(const FeatureType &type, const VALUE &value, const Label label, const HASHER &hasher=HASHER()) {
      static_assert(sizeof(typename HASHER::result_type) == 8, "64-bit hash function required");
      return _find(type, value, label, hasher);
    }

    template <typename VALUE, typename HASHER=schwa::Hasher64<VALUE>>
    inline const_iterator
    find(const FeatureType &type, const VALUE &value, const Label label, const HASHER &hasher=HASHER()) const {
      static_assert(sizeof(typename HASHER::result_type) == 8, "64-bit hash function required");
      return _find(type, value, label, hasher);
    }

    // Element access
    template <typename VALUE, typename HASHER=schwa::Hasher64<VALUE>>
    inline reference
    get(const FeatureType &type, const VALUE &value, const Label label, const HASHER &hasher=HASHER()) {
      static_assert(sizeof(typename HASHER::result_type) == 8, "64-bit hash function required");
      return _get(type, value, label, hasher);
    }

    template <typename VALUE, typename HASHER=schwa::Hasher64<VALUE>>
    inline const_reference
    get(const FeatureType &type, const VALUE &value, const Label label, const HASHER &hasher=HASHER()) const {
      static_assert(sizeof(typename HASHER::result_type) == 8, "64-bit hash function required");
      return _get(type, value, label, hasher);
    }

    template <typename VALUE, typename HASHER=schwa::Hasher64<VALUE>>
    inline reference
    operator ()(const FeatureType &type, const VALUE &value, const Label label, const HASHER &hasher=HASHER()) {
      static_assert(sizeof(typename HASHER::result_type) == 8, "64-bit hash function required");
      return _get(type, value, label, hasher);
    }

    template <typename VALUE, typename HASHER=schwa::Hasher64<VALUE>>
    inline const_reference
    operator ()(const FeatureType &type, const VALUE &value, const Label label, const HASHER &hasher=HASHER()) const {
      static_assert(sizeof(typename HASHER::result_type) == 8, "64-bit hash function required");
      return _get(type, value, label, hasher);
    }

    // Modifiers
    inline void
    clear(void) {
      _size = 0;
      for (auto &entry : *this)
        entry.clear();
    }

    // Serialisation
    void
    deserialise(std::istream &in) {
      _size = msgpack::read_map_size(in);
      for (size_t n = 0; n != _size; ++n) {
        const size_t index = msgpack::read_uint(in);
        _table[index].deserialise(in);
      }
    }

    void
    serialise(std::ostream &out) const {
      msgpack::write_map_size(out, _size);
      for (auto &entry : *this) {
        const size_t index = &entry - _table;
        msgpack::write_uint(out, index);
        entry.serialise(out);
      }
    }


    // Iteration through each label for a particular contextual predicate.
    template <typename VALUE, typename FN, typename HASHER=schwa::Hasher64<VALUE>>
    inline void
    for_each_label(const FeatureType &type, const VALUE &value, const Label label_begin, const Label label_end, FN &fn, const HASHER &hasher=HASHER()) const {
      static_assert(sizeof(typename HASHER::result_type) == 8, "64-bit hash function required");
      const uint64_t hash = _hash(type, value, hasher);
      _for_each_label(type, hash, label_begin, label_end, fn);
    }

  private:
    SCHWA_DISALLOW_COPY_AND_ASSIGN(FeatureHashtable);
  };

}

#endif  // SCHWA_HASHTABLE_H_
