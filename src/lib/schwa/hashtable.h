/* -*- Mode: C++; indent-tabs-mode: nil -*- */
#ifndef SCHWA_HASHTABLE_H_
#define SCHWA_HASHTABLE_H_

#include <map>

#include <cstdlib>
#include <iterator>
#include <iomanip>
#include <iostream>
#include <memory>
#include <new>
#include <type_traits>
#include <stdexcept>

#include <schwa/_base.h>
#include <schwa/io/logging.h>
#include <schwa/hash.h>
#include <schwa/msgpack.h>


namespace schwa {

#if 0
  enum class FeatureStorage : uint8_t {
    UNSPECIFIED, DENSE, SPARSE,
  };


  class FeatureType {
  public:
    using id_type = uint8_t;

  private:
    const id_type _id;
    FeatureStorage _storage;

  public:
    explicit FeatureType(id_type id, FeatureStorage storage=FeatureStorage::UNSPECIFIED) : _id(id), _storage(storage) { }

    inline id_type id(void) const { return _id; }
    inline FeatureStorage storage(void) const { return _storage; }

    inline void set_storage(FeatureStorage storage) { _storage = storage; }

  private:
    SCHWA_DISALLOW_COPY_AND_ASSIGN(FeatureType);
  };


  using Label = uint16_t;


  struct FeatureHashtableEntryBase {
  public:
    static_assert(sizeof(Label) == 2, "Unexpected sizeof(Label)");

    static constexpr const size_t HASH_BITS = 48;
    static constexpr const size_t DENSE_SHIFT = 64 - HASH_BITS - 1;
    static constexpr const size_t LABEL_SHIFT = DENSE_SHIFT;
    static constexpr const uint64_t HASH_MASK = ~((static_cast<uint64_t>(1) << (64 - HASH_BITS)) - static_cast<uint64_t>(1));
    static constexpr const uint64_t DENSE_MASK = static_cast<uint64_t>(1) << DENSE_SHIFT;
    static constexpr const uint64_t LABEL_MASK = (static_cast<uint64_t>(1) << LABEL_SHIFT) - static_cast<uint64_t>(1);

  protected:
    uint64_t _value;  //!< The top 48 bits are for the hash and the bottom 16 bits are for the label.

  public:
    FeatureHashtableEntryBase(void) : _value(0) { }
    FeatureHashtableEntryBase(uint64_t masked_hash, bool is_dense, Label label) : _value(build_value(masked_hash, is_dense, label)) { }
    FeatureHashtableEntryBase(const FeatureHashtableEntryBase &o) : _value(o._value) { }
    FeatureHashtableEntryBase(const FeatureHashtableEntryBase &&o) : _value(o._value) { }

    inline bool is_dense(void) const { return (_value & DENSE_MASK) != 0; }
    inline uint16_t label(void) const { return _value & LABEL_MASK; }
    inline uint64_t masked_hash(void) const { return _value & HASH_MASK; }
    inline uint64_t value(void) const { return _value; }
    //inline void set_label(const Label label) { _value = ((_value & HASH_MASK) | label); }
    //inline void set_masked_hash(const uint64_t masked_hash) { _value = (masked_hash | (_value & LABEL_MASK)); }
    inline void set_value(const uint64_t value) { _value = value; }

    static inline uint64_t build_value(const uint64_t masked_hash, const bool is_dense, const Label label) { return masked_hash | (static_cast<uint64_t>(is_dense) << DENSE_SHIFT) | static_cast<uint64_t>(label & LABEL_MASK); }
    static inline uint64_t mask_hash(const uint64_t hash) { return hash & HASH_MASK; }

    inline FeatureHashtableEntryBase &
    operator =(const FeatureHashtableEntryBase &o) {
      _value = o._value;
      return *this;
    }
  };


  /**
   * This table assumes that the hash value of 0 cannot be generated by the hasher.
   * ENTRY type:
   * - must be a subclass of FeatureHashtableEntryBase
   * - must be default constructable, copy constructable, and assignable
   * - must not be virtual
   *
   * ENTRY classes should define the \p clear, \p deserialise, and \p serialise methods,
   * accounting for the \p _value member in FeatureHashtableEntryBase. They are non-virtual for
   * speed reasons.
   *
   * This class is not thread-safe.
   **/
  template <typename ENTRY, size_t INDEX_BITS=24, typename ALLOC=std::allocator<ENTRY>>
  class FeatureHashtable {
  public:
    static_assert(std::is_base_of<FeatureHashtableEntryBase, ENTRY>::value, "ENTRY type must be a subclass of FeatureHashtableEntryBase.");
    static_assert(std::is_assignable<ENTRY, ENTRY>::value, "ENTRY type must be assignable.");
    static_assert(std::is_copy_constructible<ENTRY>::value, "ENTRY type must be copy constructable.");
    static_assert(std::is_default_constructible<ENTRY>::value, "ENTRY type must be default constructable.");
    static_assert(std::has_virtual_destructor<ENTRY>::value == false, "ENTRY type cannot be virtual.");
    static_assert(INDEX_BITS > 0, "INDEX_BITS must be non-zero");
    static_assert(INDEX_BITS <= 64, "INDEX_BITS cannot exceed 64 since the hash function is 64-bit.");

    using allocator_type = ALLOC;
    using difference_type = ptrdiff_t;
    using mapped_type = ENTRY;
    using size_type = size_t;

    using reference = typename allocator_type::reference;
    using const_reference = typename allocator_type::const_reference;
    using pointer = typename allocator_type::pointer;
    using const_pointer = typename allocator_type::const_pointer;

    static constexpr const size_t TABLE_INDEX_BITS = INDEX_BITS;  //!< Number of bits from the hash to use as the index into the table.
    static constexpr const uint64_t TABLE_INDEX_MASK = (static_cast<uint64_t>(1) << TABLE_INDEX_BITS) - static_cast<uint64_t>(1);
    static constexpr const size_t TABLE_SIZE = static_cast<size_t>(1) << TABLE_INDEX_BITS;

    //static constexpr const uint64_t PROBING_PRIME = 941;

  private:
    template <typename TABLE>
    class _iterator : public std::iterator<std::forward_iterator_tag, typename TABLE::mapped_type> {
    public:
      using super_type = std::iterator<std::forward_iterator_tag, typename TABLE::mapped_type>;
      using difference_type = typename super_type::difference_type;
      using iterator_category = typename super_type::iterator_category;
      using pointer = typename super_type::pointer;
      using reference = typename super_type::reference;
      using value_type = typename super_type::value_type;

    private:
      mutable bool _ended;
      mutable bool _initialised;
      mutable TABLE *_ht;
      mutable size_t _index;

      void
      _increment(void) const {
        // Don't do anything if it's at the end.
        if (SCHWA_UNLIKELY(_ended))
          return;
        while (true) {
          // Increment the index if not initialised.
          if (SCHWA_LIKELY(_initialised))
            ++_index;
          else
            _initialised = true;
          // Have we reached the end of the table?
          if (_index == _ht->max_size()) {
            _ended = true;
            _ht = nullptr;
            _index = 0;
            break;
          }
          // Otherwise, is the current entry filled?
          reference entry = _ht->_table[_index];
          if (entry.masked_hash() != 0)
            break;
        }
      }

    public:
      _iterator(void) : _ended(true), _initialised(true), _ht(nullptr), _index(0) { }
      explicit _iterator(TABLE &ht) : _ended(false), _initialised(false), _ht(&ht), _index(0) { }
      _iterator(TABLE &ht, size_t index) : _ended(false), _initialised(true), _ht(&ht), _index(index) { }
      _iterator(const _iterator &o) : _ended(o._ended), _initialised(o._initialised), _ht(o._ht), _index(o._index) { }
      _iterator(const _iterator &&o) : _ended(o._ended), _initialised(o._initialised), _ht(o._ht), _index(o._index) { }
      ~_iterator(void) { }

      inline bool
      operator ==(const _iterator &o) const {
        if (SCHWA_UNLIKELY(!_initialised))
          _increment();
        if (SCHWA_UNLIKELY(!o._initialised))
          o._increment();
        return _ended == o._ended && _initialised == o._initialised && _ht == o._ht && _index == o._index;
      }
      inline bool operator !=(const _iterator &o) const { return !(*this == o); }

      inline reference
      operator *(void) const {
        if (SCHWA_UNLIKELY(!_initialised))
          _increment();
        return _ht->_table[_index];
      }
      inline pointer operator ->(void) const { return &(**this); }

      inline _iterator &
      operator ++(void) {
        if (SCHWA_UNLIKELY(!_initialised))
          _increment();
        _increment();
        return *this;
      }
      inline _iterator operator ++(int) { iterator it(*this); ++(*this); return it; }

      _iterator &
      operator =(const _iterator &o) {
        _ended = o._ended;
        _initialised = o._initialised;
        _ht = o._ht;
        _index = o._index;
        return *this;
      }

      friend inline std::ostream &
      operator <<(std::ostream &out, const _iterator &it) {
        return out << "[" << it._ended << " " << it._initialised << " " << it._ht << " " << it._index << "]";
      }
    };

  public:
    using iterator = _iterator<FeatureHashtable>;
    using const_iterator = _iterator<const FeatureHashtable>;

    friend class _iterator<FeatureHashtable>;
    friend class _iterator<const FeatureHashtable>;

  private:
    mutable third_party::xxhash::XXH64_stateSpace_t _xxhash_state;  //<! State object to maintain partial xxhash state.
    allocator_type _allocator;  //!< Allocator instance.
    mapped_type *const _table;  //!< The underlying table. No chaining as collisions are accepted.
    size_type _size;  //!< The population count; how many entries exist in the table.
    //mutable std::map<uint32_t, uint64_t> _bins[3];

    inline reference
    _create_entry(reference entry, const uint64_t value) {
      //LOG(INFO) << "[_create_entry] creating entry=" << entry << std::endl;
      ++_size;
      entry.set_value(value);
      return entry;
    }


    iterator
    _locate_or_create_dense(const size_t start_index, const Label label, const uint64_t value) {
      const size_t index = (start_index + label) & TABLE_INDEX_MASK;
      reference entry = _table[index];
      const uint64_t entry_value = entry.value();

      // If the entry is unoccupied, create an entry and return an iterator to the position in the table.
      if (entry_value == 0) {
        _create_entry(entry, value);
        return iterator(*this, index);
      }

      // If the entry is the same as the key, return an iterator to the entry.
      if (entry_value == value)
        return iterator(*this, index);

      // The expected slot has been filled by another feature. Quadratic probing.
      size_t sparse_start_index = (index + 2*1 + 1) & TABLE_INDEX_MASK;

      if (entry.is_dense()) {
        //LOG(INFO) << "[_locate_or_create_dense] not relocating existing DENSE entry entry_value=0x" << std::hex << entry_value << ". relocating self value=0x" << std::hex << value << " instead." << std::dec << std::endl;
        // This feature will have to be stored sparse since another dense feature got here first.
        return _locate_or_create_sparse(sparse_start_index, value, 1);
      }
      else {
        //LOG(INFO) << "[_locate_or_create_dense] relocating existing SPARSE entry entry_value=0x" << std::hex << entry_value << " value=0x" << std::hex << value << " entry=" << entry << std::dec << std::endl;
        // Make a temporary copy of the existing entry ands et the value of the entry to be not zero and not the existing value so that the following _locate_sparse call does not yield it.
        mapped_type tmp = entry;
        entry.set_value(value);

        bool sparse_exists = false;
        iterator sparse_it = _locate_sparse(sparse_start_index, tmp.value(), sparse_exists, 1);
        if (SCHWA_UNLIKELY(sparse_exists))
          throw std::runtime_error("[_locate_or_create_dense] This should not ever happen");
        if (SCHWA_UNLIKELY(sparse_it == end()))
          return sparse_it;
        //LOG(INFO) << "[_locate_or_create_dense] before=" << *sparse_it << std::endl;
        *sparse_it = tmp;
        //LOG(INFO) << "[_locate_or_create_dense] after=" << *sparse_it << std::endl;

        // FIXME what should we do if a dense feature index doesn't have the correct hash in the entry?
        entry.clear();
        _create_entry(entry, value);
        return iterator(*this, index);
      }
    }

    iterator
    _locate_or_create_sparse(const size_t start_index, const uint64_t value, const size_t existing_misses=0) {
      // Probe the table entries.
      size_t index = start_index;
      for (size_t nmisses = existing_misses + 1; nmisses != TABLE_SIZE; ++nmisses) {
        // Get the next entry and its masked hash.
        reference entry = _table[index];
        const uint64_t entry_value = entry.value();

        // If the entry is unoccupied, create the entry and return an iterator to the position in the table.
        if (entry_value == 0) {
          _create_entry(entry, value);
          return iterator(*this, index);
        }

        // If the entry is the same as the key, return an iterator to the entry.
        if (entry_value == value)
          return iterator(*this, index);

        // Quadratic probing.
        index = (index + 2*nmisses + 1) & TABLE_INDEX_MASK;  // (s + (j + 1)^2) - (s + j^2) = 2j + 1 = 2*j + 1
      }

      // The table is full and the entry does not exist.
      return end();
    }

    inline iterator
    _locate_or_create(const FeatureType &type, const uint64_t hash, const Label label) {
      const bool is_dense = type.storage() == FeatureStorage::DENSE;
      const uint64_t masked_hash = FeatureHashtableEntryBase::mask_hash(hash);
      const uint64_t value = FeatureHashtableEntryBase::build_value(masked_hash, is_dense, label);
      const size_t start_index = hash & TABLE_INDEX_MASK;
      //LOG(INFO) << "[_locate_or_create] hash=0x" << std::hex << hash << " masked_hash=0x" << std::hex << masked_hash << " start_index=" << std::dec << start_index << std::endl;

      // Unless the feature type storage is defined to be DENSE, use sparse features.
      if (is_dense)
        return _locate_or_create_dense(start_index, label, value);
      else
        return _locate_or_create_sparse(start_index, value);
    }


    iterator
    _locate_dense(const size_t start_index, const Label label, const uint64_t value, bool &exists) {
      throw std::runtime_error("[_locate_dense] This shouldn't be called");
      const size_t index = (start_index + label) % TABLE_SIZE;
      reference entry = _table[index];
      const uint64_t entry_value = entry.value();
      //LOG(INFO) << "[_locate_dense] index=" << std::dec << index << " entry_value=0x" << std::hex << entry_value << " value=0x" << std::hex << value << " label=" << std::dec << label << std::endl;

      // If the entry is unoccupied, return an iterator to the position in the table.
      if (entry_value == 0) {
        exists = false;
        return iterator(*this, index);
      }

      // If the entry is the same as the key, return an iterator to the entry.
      if (entry_value == value) {
        exists = true;
        return iterator(*this, index);
      }

      // The expected slot has been filled by another feature.
      //LOG(INFO) << "[_locate_dense] relocating existing entry entry_value=0x" << std::hex << entry_value << " value=0x" << std::hex << value << " entry=" << entry << std::dec << std::endl;
      mapped_type tmp = entry;  // Make a temporary copy of the existing entry.
      entry.set_value(value);  // Set the value of the entry to be not zero and not the existing value so that the following _locate_sparse call does not yield it.

      // Quadratic probing
      const size_t sparse_start_index = (index + 2*1 + 1) & TABLE_INDEX_MASK;
      iterator sparse_it = _locate_sparse(sparse_start_index, tmp.value(), exists, 1);
      if (SCHWA_UNLIKELY(exists))
        throw std::runtime_error("[_locate_dense] This should not ever happen");
      if (SCHWA_UNLIKELY(sparse_it == end())) {
        exists = false;
        return sparse_it;
      }
      //LOG(INFO) << "[_locate_dense] before=" << *sparse_it << std::endl;
      *sparse_it = tmp;
      //LOG(INFO) << "[_locate_dense] after=" << *sparse_it << std::endl;

      // FIXME what should we do if a dense feature index doesn't have the correct hash in the entry?
      //LOG(INFO) << "[_locate_dense] FIXME entry_value=0x" << std::hex << entry_value << " value=0x" << std::hex << value << std::dec << std::endl;
      entry.clear();
      exists = false;
      return iterator(*this, index);
    }

    iterator
    _locate_sparse(const size_t start_index, const uint64_t value, bool &exists, const size_t existing_misses=0) {
      // Probe the table entries.
      size_t index = start_index;
      for (size_t nmisses = existing_misses + 1; nmisses != TABLE_SIZE; ++nmisses) {
        // Get the next entry and its masked hash.
        const_reference entry = _table[index];
        const uint64_t entry_value = entry.value();

        // If the entry is unoccupied, return an iterator to the position in the table.
        if (entry_value == 0) {
          exists = false;
          return iterator(*this, index);
        }

        // If the entry is the same as the key, return an iterator to the entry.
        if (entry_value == value) {
          exists = true;
          return iterator(*this, index);
        }

        // Quadratic probing.
        //LOG(INFO) << "[_locate_sparse] nmisses=" << std::dec << nmisses << " index=" << std::dec << index << " entry_value=0x" << std::hex << entry_value << std::endl;
        index = (index + 2*nmisses + 1) & TABLE_INDEX_MASK;  // (s + (j + 1)^2) - (s + j^2) = 2j + 1 = 2*j + 1
      }

      // The table is full and the entry does not exist.
      exists = false;
      return end();
    }

    inline iterator
    _locate(const FeatureType &type, const uint64_t hash, const Label label, uint64_t &masked_hash, bool &exists) {
      masked_hash = FeatureHashtableEntryBase::mask_hash(hash);
      const bool is_dense = type.storage() == FeatureStorage::DENSE;
      const uint64_t value = FeatureHashtableEntryBase::build_value(masked_hash, is_dense, label);
      const size_t start_index = hash & TABLE_INDEX_MASK;
      //LOG(INFO) << "[_locate] hash=0x" << std::hex << hash << " masked_hash=0x" << std::hex << masked_hash << " start_index=" << std::dec << start_index << std::endl;

      // Unless the feature type storage is defined to be DENSE, use sparse features.
      if (is_dense)
        return _locate_dense(start_index, label, value, exists);
      else
        return _locate_sparse(start_index, value, exists);
    }


    const_iterator
    _locate_dense(const size_t start_index, const Label label, const uint64_t value) const {
      const size_t index = (start_index + label) % TABLE_SIZE;
      const_reference entry = _table[index];
      const uint64_t entry_value = entry.value();
      //LOG(INFO) << "[_locatewdense const] index=" << std::dec << index << " entry_value=0x" << std::hex << entry_value << std::endl;

      // If the entry is unoccupied, return not found.
      if (entry_value == 0)
        return cend();

      // If the entry is the same as the key, return an iterator to the entry.
      if (entry_value == value)
        return const_iterator(*this, index);

      // FIXME what should we do if a dense feature index doesn't have the correct hash in the entry?
      //LOG(INFO) << "[_locate_dense const] FIXME what should we do if a dense feature index doesn't have the correct hash in the entry?" << std::endl;
      return const_iterator(*this, index);
    }

    const_iterator
    _locate_sparse(const size_t start_index, const uint64_t value) const {
      // Probe the table entries.
      size_t index = start_index;
      for (size_t nmisses = 1; nmisses != TABLE_SIZE; ++nmisses) {
        // Get the next entry and its masked hash.
        const pointer entry = &_table[index];
        const uint64_t entry_value = entry->value();

        // If the entry is unoccupied, return not found.
        if (entry_value == 0)
          return cend();

        // If the entry is the same as the key, return an iterator to the entry.
        if (entry_value == value)
          return const_iterator(*this, index);

        // Quadratic probing.
        //LOG(INFO) << "[_locate_sparse const] index=" << std::dec << index << " entry_value=0x" << std::hex << entry_value << std::endl;
        index = (index + 2*nmisses + 1) & TABLE_INDEX_MASK;  // (s + (j + 1)^2) - (s + j^2) = 2j + 1
      }

      // The entry does not exist.
      return cend();
    }

    inline const_iterator
    _locate(const FeatureType &type, const uint64_t hash, const Label label) const {
      const bool is_dense = type.storage() == FeatureStorage::DENSE;
      const size_t start_index = hash & TABLE_INDEX_MASK;
      const uint64_t masked_hash = FeatureHashtableEntryBase::mask_hash(hash);
      const uint64_t value = FeatureHashtableEntryBase::build_value(masked_hash, is_dense, label);
      //LOG(INFO) << "[_locate const] hash=0x" << std::hex << hash << " masked_hash=0x" << std::hex << masked_hash << " start_index=" << std::dec << start_index << std::endl;

      // Unless the feature type storage is defined to be DENSE, use sparse features.
      if (is_dense)
        return _locate_dense(start_index, label, value);
      else
        return _locate_sparse(start_index, value);
    }


    template <typename FN>
    void
    _for_each_label_dense(const size_t start_index, const uint64_t masked_hash, const Label label_begin, const Label label_end, FN &fn, uint32_t &nprobes, uint32_t &nsparse) const {
      size_t index = (start_index + label_begin) & TABLE_INDEX_MASK;

      for (Label label = label_begin; label != label_end; ++label, ++index, ++nprobes) {
        if (SCHWA_UNLIKELY(index == TABLE_SIZE))
          index = 0;
        const_reference entry = _table[index];
        const uint64_t masked_entry_hash = entry.masked_hash();

        if (masked_entry_hash == masked_hash)
          fn(label, entry);
        else if (masked_entry_hash != 0 && entry.is_dense()) {
          ++nsparse;
          ++nprobes;
          // FIXME what should we do if a dense feature index doesn't have the correct hash in the entry?
          //LOG(INFO) << "[_for_each_label_dense] unexpected situation! index=" << std::dec << index << " masked_entry_hash=0x" << std::hex << masked_entry_hash << " masked_hash=0x" << std::hex << masked_hash << std::dec << std::endl;
          // Quadratic probing.
          const size_t sparse_start_index = (index + 2*1 + 1) & TABLE_INDEX_MASK;
          _for_each_label_sparse(sparse_start_index, masked_hash, label, fn, nprobes);
        }
      }
    }

    template <typename FN>
    void
    _for_each_label_sparse(const size_t start_index, const uint64_t masked_hash, const Label label, FN &fn, uint32_t &nprobes) const {
      // Probe the table entries.
      size_t index = start_index;
      for (size_t nmisses = 2; nmisses != TABLE_SIZE; ++nmisses, ++nprobes) {
        // Get the next entry and its masked hash.
        const_reference entry = _table[index];
        const uint64_t masked_entry_hash = entry.masked_hash();

        // If the entry is unoccupied, bail.
        if (masked_entry_hash == 0)
          break;

        // If the masked hash is the same, extract the label.
        if (masked_entry_hash == masked_hash) {
          fn(label, entry);
          break;
        }

        // Quadratic probing.
        index = (index + 2*nmisses + 1) & TABLE_INDEX_MASK;  // (s + (j + 1)^2) - (s + j^2) = 2j + 1 = 2*j + 1
      }
    }

    template <typename FN>
    void
    _for_each_label_sparse(const size_t start_index, const uint64_t masked_hash, const Label label_begin, const Label label_end, FN &fn, uint32_t &nprobes) const {
      // Probe the table entries.
      size_t index = start_index;
      for (size_t nmisses = 1; nmisses != TABLE_SIZE; ++nmisses, ++nprobes) {
        // Get the next entry and its masked hash.
        const_reference entry = _table[index];
        const uint64_t masked_entry_hash = entry.masked_hash();

        // If the entry is unoccupied, bail.
        if (masked_entry_hash == 0)
          break;

        // If the masked hash is the same, extract the label.
        if (masked_entry_hash == masked_hash) {
          const Label label = entry.label();
          if (SCHWA_LIKELY(label >= label_begin && label < label_end))
            fn(label, entry);
        }

        // Quadratic probing.
        index = (index + 2*nmisses + 1) & TABLE_INDEX_MASK;  // (s + (j + 1)^2) - (s + j^2) = 2j + 1
      }
    }

    template <typename FN>
    uint32_t
    _for_each_label(const FeatureType &type, const uint64_t hash, const Label label_begin, const Label label_end, FN &fn) const {
      const size_t start_index = hash & TABLE_INDEX_MASK;
      const uint64_t masked_hash = FeatureHashtableEntryBase::mask_hash(hash);
      uint32_t nprobes = 0, nsparse = 0;

      // Unless the feature type storage is defined to be DENSE, use sparse features.
      if (type.storage() == FeatureStorage::DENSE) {
        _for_each_label_dense(start_index, masked_hash, label_begin, label_end, fn, nprobes, nsparse);
        //_bins[0][nprobes] += 1;
        //_bins[2][nsparse] += 1;
        return nsparse;
      }
      else {
        _for_each_label_sparse(start_index, masked_hash, label_begin, label_end, fn, nprobes);
        //_bins[1][nprobes] += 1;
        return 0;
      }
    }


    /**
     * Hashes together the feature type identifier and the contextual predicate using xxhash's
     * state-based hasher to form a combined digest. Returns the resultant hash.
     **/
    template <typename CP, typename HASHER>
    inline uint64_t
    _hash(const FeatureType &type, const CP &cp, const HASHER &hasher) const {
      //const FeatureType::id_type type_id = type.id();
      //third_party::xxhash::XXH64_resetState(&_xxhash_state, 0);
      //schwa::Hasher64<decltype(type_id)>()(type_id, &_xxhash_state);
      third_party::xxhash::XXH64_resetState(&_xxhash_state, static_cast<uint64_t>(982451653)*static_cast<uint64_t>(type.id()));
      hasher(cp, &_xxhash_state);
      return third_party::xxhash::XXH64_intermediateDigest(&_xxhash_state);
    }


    // ============================================================================================
    template <typename CP, typename HASHER>
    inline iterator
    _find(const FeatureType &type, const CP &cp, const Label label, const HASHER &hasher) {
      const uint64_t hash = _hash(type, cp, hasher);
      uint64_t masked_hash;
      bool exists;
      iterator it = _locate(type, hash, label, masked_hash, exists);
      return exists ? it : end();
    }

    template <typename CP, typename HASHER>
    inline const_iterator
    _find(const FeatureType &type, const CP &cp, const Label label, const HASHER &hasher) const {
      const uint64_t hash = _hash(type, cp, hasher);
      return _locate(type, hash, label);
    }

    template <typename CP, typename HASHER>
    inline reference
    _get(const FeatureType &type, const CP &cp, const Label label, const HASHER &hasher) {
      const uint64_t hash = _hash(type, cp, hasher);
      //LOG(INFO) << "[_get] type.id=" << static_cast<unsigned int>(type.id()) << " type.is_dense?=" << (type.storage() == FeatureStorage::DENSE) << " label=" << label << " hash=0x" << std::hex << hash << std::dec << " cp=" << cp << std::endl;
      iterator it = _locate_or_create(type, hash, label);
      if (SCHWA_UNLIKELY(it == end()))
        throw std::out_of_range("The table is full and the entry does not already exist in the table.");
      return *it;
    }

    template <typename CP, typename HASHER>
    inline const_reference
    _get(const FeatureType &type, const CP &cp, const Label label, const HASHER &hasher) const {
      const uint64_t hash = _hash(type, cp, hasher);
      const_iterator it = _locate(type, hash, label);
      if (SCHWA_UNLIKELY(it == cend()))
        throw std::out_of_range("The entry does not exist in the table.");
      return *it;
    }

  public:
    explicit FeatureHashtable(const allocator_type &allocator=allocator_type()) :
        _allocator(allocator),
        _table(_allocator.allocate(TABLE_SIZE)),
        _size(0)
      {
      // Construct the table objects.
      for (size_t i = 0; i != TABLE_SIZE; ++i)
        _allocator.construct(_table + i);
    }

    ~FeatureHashtable(void) {
      // Destruct the table objects and dealloc the table.
      for (size_t i = 0; i != TABLE_SIZE; ++i)
        _allocator.destroy(_table + i);
      _allocator.deallocate(_table, TABLE_SIZE);
    }


    // Capacity
    inline bool empty(void) const { return _size == 0; }
    inline size_type max_size(void) const { return TABLE_SIZE; }
    inline size_type size(void) const { return _size; }

    // Iterators
    inline iterator begin(void) { return iterator(*this); }
    inline iterator end(void) { return iterator(); }
    inline const_iterator begin(void) const { return const_iterator(*this); }
    inline const_iterator end(void) const { return const_iterator(); }
    inline const_iterator cbegin(void) const { return const_iterator(*this); }
    inline const_iterator cend(void) const { return const_iterator(); }

    // Observers
    inline allocator_type get_allocator(void) const noexcept { return _allocator; }

    // Hash policy
    inline float load_factor(void) const noexcept { return _size / static_cast<float>(TABLE_SIZE); }

    // Element lookup
    template <typename CP, typename HASHER=schwa::Hasher64<CP>>
    inline iterator
    find(const FeatureType &type, const CP &contextual_predicate, const Label label, const HASHER &hasher=HASHER()) {
      static_assert(sizeof(typename HASHER::result_type) == 8, "64-bit hash function required");
      return _find(type, contextual_predicate, label, hasher);
    }

    template <typename CP, typename HASHER=schwa::Hasher64<CP>>
    inline const_iterator
    find(const FeatureType &type, const CP &contextual_predicate, const Label label, const HASHER &hasher=HASHER()) const {
      static_assert(sizeof(typename HASHER::result_type) == 8, "64-bit hash function required");
      return _find(type, contextual_predicate, label, hasher);
    }

    // Element access
    template <typename CP, typename HASHER=schwa::Hasher64<CP>>
    inline reference
    get(const FeatureType &type, const CP &contextual_predicate, const Label label, const HASHER &hasher=HASHER()) {
      static_assert(sizeof(typename HASHER::result_type) == 8, "64-bit hash function required");
      return _get(type, contextual_predicate, label, hasher);
    }

    template <typename CP, typename HASHER=schwa::Hasher64<CP>>
    inline const_reference
    get(const FeatureType &type, const CP &contextual_predicate, const Label label, const HASHER &hasher=HASHER()) const {
      static_assert(sizeof(typename HASHER::result_type) == 8, "64-bit hash function required");
      return _get(type, contextual_predicate, label, hasher);
    }

    template <typename CP, typename HASHER=schwa::Hasher64<CP>>
    inline reference
    operator ()(const FeatureType &type, const CP &contextual_predicate, const Label label, const HASHER &hasher=HASHER()) {
      static_assert(sizeof(typename HASHER::result_type) == 8, "64-bit hash function required");
      return _get(type, contextual_predicate, label, hasher);
    }

    template <typename CP, typename HASHER=schwa::Hasher64<CP>>
    inline const_reference
    operator ()(const FeatureType &type, const CP &contextual_predicate, const Label label, const HASHER &hasher=HASHER()) const {
      static_assert(sizeof(typename HASHER::result_type) == 8, "64-bit hash function required");
      return _get(type, contextual_predicate, label, hasher);
    }

    // Modifiers
    inline void
    clear(void) {
      _size = 0;
      for (auto &entry : *this)
        entry.clear();
      //for (unsigned int i = 0; i != 3; ++i)
        //_bins[i].clear();
    }

    // Serialisation
    void
    deserialise(std::istream &in) {
      _size = msgpack::read_map_size(in);
      for (size_t n = 0; n != _size; ++n) {
        const size_t index = msgpack::read_uint(in);
        _table[index].deserialise(in);
      }
    }

    void
    serialise(std::ostream &out) const {
      msgpack::write_map_size(out, _size);
      size_type count = 0;
      for (const auto &entry : *this) {
        const size_t index = &entry - _table;
        msgpack::write_uint(out, index);
        entry.serialise(out);
        ++count;
      }
      LOG(INFO) << "FeatureHashtable::serialise count=" << std::dec << count << " _size=" << _size << std::endl;
      if (SCHWA_UNLIKELY(count != _size))
        throw std::runtime_error("Serialised count != expected count");

      //double total;
      //LOG(INFO) << "nprobes DENSE" << std::endl;
      //total = 0;
      //for (const auto &pair : _bins[0])
        //total += pair.second;
      //for (const auto &pair : _bins[0])
        //LOG(INFO) << " " <<  pair.first << " => " << pair.second << " (" << ((100.0 * pair.second) / total) << ")" << std::endl;

      //LOG(INFO) << "nprobes SPARSE" << std::endl;
      //total = 0;
      //for (const auto &pair : _bins[1])
        //total += pair.second;
      //for (const auto &pair : _bins[1])
        //LOG(INFO) << " " << pair.first << " => " << pair.second << " (" << ((100.0 * pair.second) / total) << ")" << std::endl;

      //LOG(INFO) << "nsparse DENSE" << std::endl;
      //total = 0;
      //for (const auto &pair : _bins[2])
        //total += pair.second;
      //for (const auto &pair : _bins[2])
        //LOG(INFO) << " " <<  pair.first << " => " << pair.second << " (" << ((100.0 * pair.second) / total) << ")" << std::endl;
    }


    // Iteration through each label for a particular contextual predicate.
    template <typename CP, typename FN, typename HASHER=schwa::Hasher64<CP>>
    inline void
    for_each_label(const FeatureType &type, const CP &contextual_predicate, const Label label_begin, const Label label_end, FN &fn, const HASHER &hasher=HASHER()) const {
      static_assert(sizeof(typename HASHER::result_type) == 8, "64-bit hash function required");
      const uint64_t hash = _hash(type, contextual_predicate, hasher);
      const uint32_t nsparse = _for_each_label(type, hash, label_begin, label_end, fn);
      (void)nsparse;
      if (nsparse >= 60) {
        LOG(INFO) << "[_for_each_label] type.id=" << static_cast<unsigned int>(type.id()) << " nsparse=" << std::dec << nsparse << " hash=0x" << std::hex << hash << std::dec << " cp=" << contextual_predicate << std::endl;
      }
    }

  private:
    SCHWA_DISALLOW_COPY_AND_ASSIGN(FeatureHashtable);
  };

#endif

}

#endif  // SCHWA_HASHTABLE_H_
